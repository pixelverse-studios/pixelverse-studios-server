This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-27T22:16:23.022Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
models/
  Clients.js
  GGC_Newsletter.js
  User.js
src/
  controllers/
    clients.ts
    cms.ts
    contact-forms.ts
    newsletter.ts
    recaptcha.ts
  lib/
    db.ts
    mailer.ts
  routes/
    clients.ts
    cms.ts
    contact-forms.ts
    middleware.ts
    newsletter.ts
    recaptcha.ts
  services/
    clients.ts
    contact-forms.ts
    websites.ts
  utils/
    mailer/
      clients/
        introMeetingResponse.js
      user/
        resetPasswordEmail.js
      emails.ts
      index.js
    http.ts
    regex.js
    token.js
  server.ts
.gitignore
.prettierrc
package.json
tsconfig.json

================================================================
Files
================================================================

================
File: models/Clients.js
================
const { model, Schema } = require('mongoose')

const clientsSchema = new Schema({
    email: { type: String, unqiue: true },
    firstName: String,
    lastName: String,
    meetings: [
        {
            location: String,
            url: String,
            created: { type: Date, default: Date.now },
            scheduledFor: Date,
            prepInfo: [
                {
                    question: String,
                    answer: String
                }
            ],
            notes: [String]
        }
    ],
    project: {
        title: String,
        domain: String,
        externalDependencies: [String],
        phases: [
            {
                originalCostEstimate: Number,
                updatedCostEstimate: Number,
                originalLaunchDate: Date,
                updatedLaunchDate: Date,
                status: String,
                notes: [String],
                amountPaid: Number,
                isActive: Boolean
            }
        ]
    },
    notes: [String],
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
})

module.exports = model('Clients', clientsSchema)

================
File: models/GGC_Newsletter.js
================
const { model, Schema } = require('mongoose')

const GgcNewsLetter = new Schema({
    email: { type: String, unqiue: true },
    // firstName: String,
    // lastName: String,
    name: String,
    subscribed: Boolean,
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
})

module.exports = model('GgcNewsletter', GgcNewsLetter)

================
File: models/User.js
================
const { model, Schema } = require('mongoose')

const userSchema = new Schema({
    email: { type: String, unqiue: true },
    firstName: String,
    lastName: String,
    password: String,
    createdAt: { type: Date, default: Date.now },
    updatedAt: Date,
    devHours: [
        {
            date: Date,
            hoursLogged: Number,
            project: String,
            projectPhase: String
        }
    ]
})

module.exports = model('User', userSchema)

================
File: src/controllers/clients.ts
================
import { Request, Response } from 'express'

import { COLUMNS, db, Tables } from '../lib/db'
import { handleGenericError } from '../utils/http'

const getAll = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { data, error } = await db.from(Tables.CLIENTS).select('*')
        if (error) {
            throw error
        }

        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const getIdBySlug = async (slug: string) => {
    try {
        const { data, error } = await db
            .from(Tables.CLIENTS)
            .select()
            .eq(COLUMNS.SLUG, slug)
            .single()

        if (error) throw new Error(error.message)
        return data.id
    } catch (err) {
        throw err
    }
}

const add = async (req: Request, res: Response): Promise<Response> => {
    const { active, client, client_slug, cms } = req.body

    try {
        const { data, error } = await db
            .from(Tables.CLIENTS)
            .insert({
                client,
                active,
                client_slug,
                updated_at: new Date(),
                cms
            })
            .select()

        if (error) {
            throw error
        }

        return res.status(201).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const edit = async (req: Request, res: Response): Promise<Response> => {
    const { id } = req.params
    const { client, active } = req.body

    try {
        const payload = {
            updated_at: new Date()
        } as { client?: string; active?: boolean; updated_at: Date }
        if (client != undefined) {
            payload.client = client
        }
        if (active != undefined) {
            payload.active = active
        }
        const { data, error } = await db
            .from(Tables.CLIENTS)
            .update(payload)
            .eq('id', id)
            .select()
            .single()

        if (data == null) {
            return res.status(404).json({ error: 'Client not found' })
        }

        if (error) {
            throw error
        }

        return res.status(201).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const remove = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { id } = req.params
        const { data, error } = await db
            .from('clients')
            .delete()
            .eq('id', id)
            .select()
            .single()

        if (!data || data.length === 0) {
            return res.status(404).json({ error: 'Client not found' })
        }

        if (error) throw error
        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

export default { add, remove, edit, getAll, getIdBySlug }

================
File: src/controllers/cms.ts
================
import { Request, Response } from 'express'

import { db, Tables, COLUMNS } from '../lib/db'
import clients from './clients'
import { handleGenericError } from '../utils/http'

const get = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { data, error } = await db.from(Tables.CMS).select()
        if (error) {
            throw error
        }

        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const getById = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { clientSlug } = req.params

        const clientId = await clients.getIdBySlug(clientSlug)
        const { data, error } = await db
            .from(Tables.CMS)
            .select()
            .eq(COLUMNS.CLIENT_ID, clientId)
        if (error) {
            throw error
        }

        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const getActiveById = async (
    req: Request,
    res: Response
): Promise<Response> => {
    try {
        const { clientSlug } = req.params
        const clientId = await clients.getIdBySlug(clientSlug)
        const { data, error } = await db
            .from(Tables.CMS)
            .select()
            .eq(COLUMNS.CLIENT_ID, clientId)
            .eq('active', true)
        if (error) {
            throw error
        }

        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const add = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { page, content, active } = req.body
        const { id } = req.params

        const { data, error } = await db
            .from(Tables.CMS)
            .insert({
                client_id: id,
                page,
                content,
                active,
                updated_at: new Date()
            })
            .select()

        if (error) throw error

        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const edit = async (req: Request, res: Response): Promise<Response> => {
    const { id } = req.params
    try {
        const { data, error } = await db
            .from(Tables.CMS)
            .update({ ...req.body, updated_at: new Date() })
            .eq('id', id)
            .select()
            .single()

        if (error) throw error
        return res.status(200).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const remove = async (req: Request, res: Response): Promise<Response> => {
    const { id } = req.params
    try {
        const { error } = await db
            .from(Tables.CMS)
            .delete()
            .eq('id', id)
            .select()
            .single()

        if (error) throw error
        return res.status(200).json(true)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

export default { add, get, getById, getActiveById, edit, remove }

================
File: src/controllers/contact-forms.ts
================
import { Request, Response } from 'express'

import { handleGenericError } from '../utils/http'
import { sendContactSubmissionEmail } from '../lib/mailer'
import websitesDB from '../services/websites'
import contactFormDB from '../services/contact-forms'

const getAll = async (req: Request, res: Response): Promise<Response> => {
    try {
        const allSubmissions =
            await contactFormDB.getAllContactFormSubmissions()

        return res.status(200).json(allSubmissions)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const addRecord = async (req: Request, res: Response): Promise<Response> => {
    const { fullname, email, phone, data: reqData } = req.body
    const { website_slug } = req.params

    console.log('--- add record ---')
    try {
        const {
            contact_email: sendToEmail,
            title,
            id: website_id
        } = await websitesDB.getWebsiteDetailsForEmail(website_slug)
        console.log({ website_slug, sendToEmail, title, website_id })

        await contactFormDB.addFormSubmissionRecord({
            website_id,
            payload: { fullname, email, phone, additional: reqData }
        })
        const payload = { additional: { ...reqData }, phone, email, fullname }

        console.log('send email out')
        await sendContactSubmissionEmail({
            to:
                process.env.NODE_ENVIRONMENT === 'development'
                    ? 'info@pixelversestudios.io'
                    : sendToEmail,
            subject: `New Contact Form Submission for ${title}`,
            website: title,
            payload
        })
        console.log('finished sending out email')

        return res.status(201)
    } catch (err) {
        console.log('err: ', err)
        return handleGenericError(err, res)
    }
}

export default { getAll, addRecord }

================
File: src/controllers/newsletter.ts
================
import { Request, Response } from 'express'

import { db, Tables } from '../lib/db'
import clients from './clients'
import { handleGenericError } from '../utils/http'

const getAll = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { data, error } = await db.from(Tables.NEWSLETTER).select('*')
        if (error) throw error
        return res.status(200).json({ newsletter: data })
    } catch (err) {
        return handleGenericError(err, res)
    }
}

const add = async (req: Request, res: Response): Promise<Response> => {
    try {
        const { clientSlug } = req.params
        const { firstName, lastName, email } = req.body

        const clientId = await clients.getIdBySlug(clientSlug)

        const { data: existingUser, error: selectError } = await db
            .from(Tables.NEWSLETTER)
            .select('*')
            .eq('email', email)
            .eq('client_id', clientId) // Optional if emails need to be unique per client
            .single()

        if (selectError && selectError.code !== 'PGRST116') {
            // 'PGRST116' is "No rows found"
            throw selectError
        }
        if (existingUser) {
            throw {
                status: 409,
                message: 'Subscriber already exists'
            }
            // res.status(409).json({ message: 'Subscriber already exists' })
        }

        const { error, data } = await db
            .from(Tables.NEWSLETTER)
            .insert([
                {
                    client_id: clientId,
                    firstname: firstName,
                    lastname: lastName,
                    email,
                    updated_at: new Date()
                }
            ])
            .select()
        if (error) throw error
        return res.status(201).json(data)
    } catch (err) {
        return handleGenericError(err, res)
    }
}

export default { add, getAll }

================
File: src/controllers/recaptcha.ts
================
import { Request, Response } from 'express'

const verifyTopNotchRecaptcha = async (
    req: Request,
    res: Response
): Promise<Response> => {
    const { token } = req.body

    if (!token) {
        return res.status(400).json({ error: 'No reCAPTCHA token provided.' })
    }

    try {
        const response = await fetch(
            `https://recaptchaenterprise.googleapis.com/v1/projects/YOUR_PROJECT_ID/assessments?key=YOUR_API_KEY`,
            {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: {
                        token: token,
                        siteKey: '6LdC3dEqAAAAACuoO_aRk_0rUm_6v0uYRUseKabC',
                        expectedAction: 'USER_ACTION'
                    }
                })
            }
        )

        const data = await response.json()

        if (!response.ok) {
            throw new Error(
                `Google reCAPTCHA API error: ${
                    data.error?.message || 'Unknown error'
                }`
            )
        }

        const riskScore = data?.riskAnalysis?.score || 0

        if (riskScore >= 0.5) {
            return res.status(200).json({
                success: true,
                message: 'reCAPTCHA verified successfully.'
            })
        } else {
            return res.status(403).json({
                success: false,
                message: 'reCAPTCHA verification failed.'
            })
        }
    } catch (error) {
        return res.status(500).json({
            error: 'Verification failed.',
            details: (error as Error).message
        })
    }
}

export default { verifyTopNotchRecaptcha }

================
File: src/lib/db.ts
================
import { createClient } from '@supabase/supabase-js'

import 'dotenv/config'

const SUPABASE_URL = process.env.SUPABASE_URL || ''
const SUPABASE_KEY = process.env.SUPABASE_KEY || ''

// Initialize the Supabase client
export const db = createClient(SUPABASE_URL, SUPABASE_KEY)

export const Tables = {
    CLIENTS: 'clients',
    CMS: 'cms',
    NEWSLETTER: 'newsletter',
    CONTACT_FORMS: 'contact_form_submissions',
    WEBSITES: 'websites'
}

export const COLUMNS = {
    CLIENT_ID: 'client_id',
    CONTACT_EMAIL: 'contact_email',
    SLUG: 'client_slug',
    WEBSITE_SLUG: 'website_slug'
}

================
File: src/lib/mailer.ts
================
import nodemailer from 'nodemailer'
import { OAuth2Client } from 'google-auth-library'
import { convert } from 'html-to-text'

import { generateContactFormSubmissionEmail } from '../utils/mailer/emails'

const GMAIL_USER = process.env.GMAIL_USER!
const GMAIL_CLIENT_ID = process.env.GMAIL_CLIENT_ID!
const GMAIL_CLIENT_SECRET = process.env.GMAIL_CLIENT_SECRET!
const GMAIL_REFRESH_TOKEN = process.env.GMAIL_REFRESH_TOKEN!

const oAuth2Client = new OAuth2Client(GMAIL_CLIENT_ID, GMAIL_CLIENT_SECRET)
oAuth2Client.setCredentials({ refresh_token: GMAIL_REFRESH_TOKEN })

interface ContactSubmissionEmailParams {
    to: string
    subject: string
    website: string
    payload: {
        fullname: string
        phone: string
        email: string
        additional: any
    }
}

export async function sendContactSubmissionEmail({
    to,
    subject,
    website,
    payload
}: ContactSubmissionEmailParams): Promise<void> {
    try {
        const accessToken = await oAuth2Client.getAccessToken()

        const transporter = nodemailer.createTransport({
            service: 'gmail',
            auth: {
                type: 'OAuth2',
                user: GMAIL_USER,
                clientId: GMAIL_CLIENT_ID,
                clientSecret: GMAIL_CLIENT_SECRET,
                refreshToken: GMAIL_REFRESH_TOKEN,
                accessToken: accessToken.token || ''
            }
        })

        const html = generateContactFormSubmissionEmail({
            website,
            fullname: payload.fullname,
            phone: payload.phone,
            email: payload.email,
            data: payload.additional
        })

        const text = convert(html)

        const mailOptions = {
            from: GMAIL_USER,
            to,
            subject,
            text,
            html
        }

        const result = await transporter.sendMail(mailOptions)
        console.log('âœ… Email sent successfully:', {
            result: result.messageId,
            sentTo: to,
            website
        })
    } catch (error) {
        console.error('âŒ Error sending email:', error)
    }
}

================
File: src/routes/clients.ts
================
import { Router } from 'express'
import { body, param } from 'express-validator'

import { validateRequest } from './middleware'
import clients from '../controllers/clients'

const clientsRouter: Router = Router()
const BASE_ROUTE = '/api/clients'

clientsRouter.get(BASE_ROUTE, clients.getAll)
clientsRouter.post(
    `${BASE_ROUTE}/new`,
    [
        body('client')
            .isString()
            .notEmpty()
            .withMessage('"client" is required'),
        body('client_slug')
            .isString()
            .notEmpty()
            .withMessage('"client slug" is required'),
        body('active').isBoolean().withMessage('"active" is required'),
        body('cms').isBoolean()
    ],
    validateRequest,
    clients.add
)
clientsRouter.patch(
    `${BASE_ROUTE}/:id`,
    [
        param('id').isNumeric().withMessage('Client ID must be a number'),
        body().custom((_, { req }) => {
            if (!req.body.client && req.body.active === undefined) {
                throw new Error(
                    'At least one of "client" or "active" is required'
                )
            }
            return true
        }),
        body('client')
            .optional()
            .isString()
            .withMessage('client must be a string')
            .notEmpty()
            .withMessage('client cannot be empty'),
        body('active')
            .optional()
            .isBoolean()
            .withMessage('active must be a boolean')
    ],
    validateRequest,
    clients.edit
)
clientsRouter.delete(
    `${BASE_ROUTE}/:id`,
    [
        param('id')
            .isNumeric()
            .withMessage('Client ID must be provided and a number')
    ],
    validateRequest,
    clients.remove
)

export default clientsRouter

================
File: src/routes/cms.ts
================
import { Router } from 'express'
import { body, param } from 'express-validator'
import { validateRequest } from './middleware'
import cms from '../controllers/cms'

const cmsRouter: Router = Router()

// TODO: Add user verification to endpoints when we have it built into the ui, for appropriate routes that are not public
const BASE_ROUTE = '/api/cms'
cmsRouter.get(BASE_ROUTE, cms.get)

cmsRouter.get(
    `${BASE_ROUTE}/:clientSlug`,
    [param('clientSlug').exists().withMessage('slug is required')],
    validateRequest,
    cms.getById
)

cmsRouter.get(
    `${BASE_ROUTE}/:clientSlug/active`,
    [param('clientSlug').exists().withMessage('slug is required')],
    validateRequest,
    cms.getActiveById
)

cmsRouter.post(
    `${BASE_ROUTE}/:id`,
    [
        param('id').exists().withMessage('slug is required'),
        body('page').isString().notEmpty().withMessage('"page" is required'),
        body('content').exists().withMessage('"content" is required'),
        body('active').exists().isBoolean()
    ],
    validateRequest,
    cms.add
)

cmsRouter.patch(
    `${BASE_ROUTE}/:id`,
    [
        param('id').exists().withMessage('id is required'),
        body('page').optional().isString().withMessage('page must be a string'),
        body('content').optional(),
        body('active').optional().isBoolean()
    ],
    validateRequest,
    cms.edit
)

cmsRouter.delete(
    `${BASE_ROUTE}/:id`,
    [param('id').isNumeric().withMessage('id must be provided and a number')],
    validateRequest,
    cms.remove
)

export default cmsRouter

================
File: src/routes/contact-forms.ts
================
import { Router } from 'express'
import { body, param } from 'express-validator'

import { validateRequest } from './middleware'
import contactForms from '../controllers/contact-forms'

const contactFormsRouter: Router = Router()
const BASE_ROUTE = '/api/v1/contact-forms'

contactFormsRouter.get(BASE_ROUTE, contactForms.getAll)

contactFormsRouter.post(
    `${BASE_ROUTE}/:website_slug`,
    [
        param('website_slug').isString().notEmpty(),
        body('fullname').isString().notEmpty(),
        body('email').isString().notEmpty(),
        body('phone').isString().notEmpty(),
        body('data').notEmpty().isObject()
    ],
    validateRequest,
    contactForms.addRecord
)

export default contactFormsRouter

================
File: src/routes/middleware.ts
================
import { Request, Response, NextFunction } from 'express'
import { validationResult } from 'express-validator'

export const validateRequest = (
    req: Request,
    res: Response,
    next: NextFunction
): Response | void => {
    const errors = validationResult(req)
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() })
    }
    next()
}

================
File: src/routes/newsletter.ts
================
import { Router } from 'express'
import { body, param } from 'express-validator'

import { validateRequest } from './middleware'
import newsletter from '../controllers/newsletter'

const newsletterRouter: Router = Router()
const BASE_ROUTE = '/api/newsletter'

newsletterRouter.get(BASE_ROUTE, newsletter.getAll)
newsletterRouter.post(
    `${BASE_ROUTE}/:clientSlug`,
    [
        param('clientSlug')
            .isString()
            .notEmpty()
            .withMessage('Client identifier is required'),
        body('firstName')
            .isString()
            .notEmpty()
            .withMessage('First name is required'),
        body('lastName')
            .isString()
            .notEmpty()
            .withMessage('First name is required'),
        body('email').isEmail().withMessage('Valid email is required')
    ],
    validateRequest,
    newsletter.add
)

export default newsletterRouter

================
File: src/routes/recaptcha.ts
================
import { Router } from 'express'

const recaptchaRouter: Router = Router()

recaptchaRouter.post('/verify-recaptcha/topnotch')

export default recaptchaRouter

================
File: src/services/clients.ts
================
import { COLUMNS, db, Tables } from '../lib/db'

export const getClientEmail = async (id: string) => {
    try {
        console.log('GET CLIENT EMAIL')
        const { data, error } = await db
            .from(Tables.CLIENTS)
            .select('email')
            .eq('id', id)
            .single()

        if (error) throw new Error(error.message)

        console.log(data)
    } catch (error) {
        throw error
    }
}

================
File: src/services/contact-forms.ts
================
import { COLUMNS, db, Tables } from '../lib/db'

const getAllContactFormSubmissions = async () => {
    try {
        const { data, error } = await db.from(Tables.CONTACT_FORMS).select()

        if (error) throw new Error(error.message)

        return data
    } catch (error) {
        throw error
    }
}

interface NewRecord {
    website_id: string
    payload: {
        fullname: string
        email: string
        phone: string
        additional: any
    }
}
const addFormSubmissionRecord = async ({ website_id, payload }: NewRecord) => {
    try {
        const { error } = await db
            .from(Tables.CONTACT_FORMS)
            .insert({
                website_id,
                fullname: payload.fullname,
                email: payload.email,
                phone: payload.phone,
                data: payload.additional
            })
            .select()

        if (error) {
            throw error
        }

        return
    } catch (error) {
        throw error
    }
}

const contactFormDB = {
    getAllContactFormSubmissions,
    addFormSubmissionRecord
}

export default contactFormDB

================
File: src/services/websites.ts
================
import { COLUMNS, db, Tables } from '../lib/db'

const getWebsiteEmail = async (id: string) => {
    try {
        const { data, error } = await db
            .from(Tables.WEBSITES)
            .select(COLUMNS.CONTACT_EMAIL)
            .eq('id', id)
            .single()

        if (error) throw new Error(error.message)

        return data ?? ''
    } catch (error) {
        throw error
    }
}

const getWebsiteDetailsForEmail = async (slug: string) => {
    try {
        const {
            data: { contact_email, title, id },
            error
        } = await db
            .from(Tables.WEBSITES)
            .select()
            .eq(COLUMNS.WEBSITE_SLUG, slug)
            .single()

        if (error) throw new Error(error.message)

        return { contact_email, title, id }
    } catch (error) {
        throw error
    }
}

const websitesDB = {
    getWebsiteEmail,
    getWebsiteDetailsForEmail
}
export default websitesDB

================
File: src/utils/mailer/clients/introMeetingResponse.js
================
const { createTransporter } = require('../')

module.exports.sendIntroMeetingResponse = async (
    sendToEmail,
    meetingDetails
) => {
    const transporter = await createTransporter()

    const header = `<header>EZPZ Coding LLC</header>`
    const body = `<div>We want to thank you for requesting to meet with us for a potential project. The meeting is on our books, we look forward to speaking with you on ${meetingDetails.location} at ${meetingDetails.dateTime}</div>`

    const html = `
        <div>
            ${header}
            ${body}
        </div>
    `

    try {
        const res = await transporter.sendMail({
            subject: 'Intro Meeting Confirmed!',
            html,
            to: sendToEmail,
            from: process.env.EMAIL_USER
        })
        return true
    } catch (error) {
        throw new Error(error)
    }
}

================
File: src/utils/mailer/user/resetPasswordEmail.js
================
const { createTransporter } = require('../')

module.exports.resetPasswordEmail = async (email, token) => {
    const transporter = await createTransporter()

    const header =
        '<header style="color: #3fc1aa; font-size: 2rem; margin-bottom: 1rem;">EZPZ Coding</header>'
    const message =
        '<div style="font-size: 1.5rem">To reset your password, click the link below.</div>'
    const pageRoute = 'password/reset'
    const url = `http://localhost:3000/${pageRoute}/${token}`
    const anchor = `<a href="${url}" target="_blank"><button style="margin: 1rem 0;background-color: #04132f;font-size: 1.5rem;color: white; cursor: pointer; border: none;height: 3rem;width: 40%; border-radius: 2%;font-weight: 500;">RESET PASSWORD</button></a>`
    const timeDisclaimer =
        '<div style="font-style=italic; font-size: 1.35rem;">For security purposes, this link above will expire within one hour.</div>'

    const html = `
        <section style="text-align: center">
            ${header}
            ${message}
            <div style="width: 100%; text-align:center;">
                ${anchor}
            </div>
            ${timeDisclaimer}
        </section>
        `

    try {
        await transporter.sendMail({
            subject: 'EZPZ Coding Password Reset',
            html,
            to: email,
            from: process.env.EMAIL_USER
        })
    } catch (error) {
        throw new Error(error)
    }
}

================
File: src/utils/mailer/emails.ts
================
interface FormSubmissionEmailProps {
    website: string
    fullname: string
    email: string
    phone: string
    data: any
}

export const generateContactFormSubmissionEmail = ({
    website,
    fullname,
    email,
    phone,
    data
}: FormSubmissionEmailProps) => {
    const formattedData = Object.entries(data)
        .map(([key, value]) => `<li><strong>${key}:</strong> ${value}</li>`)
        .join('')

    return `
    <div style="max-width: 600px; margin: 20px auto; background: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.1); font-family: Arial, sans-serif; background-color: #1e1e1e; color: #ffffff;">
        <div style="background-color: #007BFF; color: #ffffff; text-align: center; padding: 15px; border-radius: 8px 8px 0 0; font-size: 20px;">
            ðŸš€ New Contact Form Submission
        </div>
        <div style="padding: 20px; color: #ffffff;">
            <p><strong>Website:</strong> ${website}</p>
            <p><strong>Full Name:</strong> ${fullname}</p>
            <p><strong>Email:</strong> <a href="mailto:${email}" style="color:#007BFF; text-decoration:none;">${email}</a></p>
            <p><strong>Phone:</strong> ${phone}</p>

            <div style="background-color: #2a2a2a; padding: 15px; border-radius: 6px; margin-top: 10px; font-size: 14px;">
                <p><strong>Submitted Data:</strong></p>
                <ul style="padding-left: 20px; list-style-type: none;">
                    ${formattedData}
                </ul>
            </div>
        </div>
        <div style="text-align: center; padding: 15px; font-size: 14px; color: #bbbbbb;">
            <p>Need assistance? <a href="mailto:support@yourcompany.com" style="color:#007BFF; text-decoration:none;">Contact Support</a></p>
        </div>
    </div>`
}

================
File: src/utils/mailer/index.js
================
const nodemailer = require('nodemailer')
const { google } = require('googleapis')

module.exports.createTransporter = async () => {
    const OAuth2 = google.auth.OAuth2
    const oauth2Client = new OAuth2(
        process.env.GOOGLE_OAUTH_ID,
        process.env.GOOGLE_OAUTH_SECRET,
        'https://developers.google.com/oauthplayground'
    )

    oauth2Client.setCredentials({
        refresh_token: process.env.GOOGLE_REFRESH_TOKEN
    })
    const accessToken = await new Promise((resolve, reject) => {
        oauth2Client.getAccessToken((err, token) => {
            if (err) {
                reject('Failed to create access token')
            }

            resolve(token)
        })
    })

    const transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
            type: 'OAuth2',
            user: process.env.EMAIL_USER,
            accessToken,
            clientId: process.env.GOOGLE_OAUTH_ID,
            clientSecret: process.env.GOOGLE_OAUTH_SECRET,
            refreshToken: process.env.GOOGLE_REFRESH_TOKEN
        }
    })

    return transporter
}

================
File: src/utils/http.ts
================
import { Response } from 'express'

export const handleGenericError = (err: any, res: Response) => {
    if (err instanceof Error) {
        return res.status(500).json({ error: err.message })
    }
    // Custom error handling
    return res.status(err.status).json({ error: err.message })
}

================
File: src/utils/regex.js
================
module.exports = {
    VALID_EMAIL:
        /^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/,
    VALID_PASSWORD: /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[!@#$%^&*]).{8,}$/
}

================
File: src/utils/token.js
================
const jwt = require('jsonwebtoken')

module.exports.generateToken = user => {
    const userData = {
        _id: user._id,
        email: user.email
    }

    return jwt.sign({ ...userData }, process.env?.TOKEN_SECRET ?? '', {
        expiresIn: process.env?.TOKEN_EXPIRE ?? '24hr'
    })
}

module.exports.generateResetPwToken = user => {
    const userData = {
        id: user._id,
        email: user.email
    }

    return jwt.sign({ ...userData }, process.env?.TOKEN_SECRET ?? '', {
        expiresIn: '1hr'
    })
}

const isTokenExpired = expiration => {
    if (expiration * 1000 < Date.now()) return false

    return true
}
module.exports.isTokenExpired = isTokenExpired

module.exports.validateToken = context => {
    const { user } = context
    if (!user) {
        return {
            valid: false,
            user
        }
    }

    return {
        valid: isTokenExpired(user.exp),
        user
    }
}

================
File: src/server.ts
================
import express, { Application } from 'express'
import bodyParser from 'body-parser'
import cors from 'cors'

import clientsRouter from './routes/clients'
import newsletterRouter from './routes/newsletter'
import cmsRouter from './routes/cms'
import contactFormsRouter from './routes/contact-forms'

import 'dotenv/config'

// Supabase URL and Key from environment variables
const app: Application = express()
const PORT = process.env.PORT || 3000

// Middleware
app.use(bodyParser.json())
app.use(cors())
// Routes
app.use(clientsRouter)
app.use(newsletterRouter)
app.use(cmsRouter)
app.use(contactFormsRouter)

// Error handling middleware
app.use(
    (
        err: any,
        req: express.Request,
        res: express.Response,
        next: express.NextFunction
    ) => {
        res.status(500).json({ message: err.message })
    }
)

// Start the server
app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`)
})

================
File: .gitignore
================
node_modules
.env
config.ts

================
File: .prettierrc
================
{
    "tabWidth": 4,
    "semi": false,
    "singleQuote": true,
    "trailingComma": "none",
    "bracketSpacing": true,
    "jsxBracketSameLine": true,
    "arrowParens": "avoid",
    "requirePragma": false,
    "insertPragma": false,
    "proseWrap": "never"
}

================
File: package.json
================
{
    "name": "ezpz-server",
    "version": "1.4.1",
    "description": "",
    "main": "server.js",
    "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "ts-node src/server.ts",
        "serve": "nodemon src/server.ts"
    },
    "author": "",
    "license": "ISC",
    "dependencies": {
        "@supabase/supabase-js": "^2.45.4",
        "bcryptjs": "^2.4.3",
        "cors": "^2.8.5",
        "date-fns": "^2.29.3",
        "dotenv": "^16.0.1",
        "express": "^4.21.0",
        "express-validator": "^7.2.0",
        "googleapis": "^100.0.0",
        "html-to-text": "^9.0.5",
        "nodemailer": "^6.10.0",
        "nodemon": "^2.0.20"
    },
    "devDependencies": {
        "@types/cors": "^2.8.17",
        "@types/express": "^4.17.21",
        "@types/express-validator": "^3.0.0",
        "@types/html-to-text": "^9.0.4",
        "@types/node": "^22.5.5",
        "@types/nodemailer": "^6.4.17",
        "ts-node": "^10.9.2",
        "typescript": "^5.6.2"
    }
}

================
File: tsconfig.json
================
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "strict": true,
        "esModuleInterop": true,
        "outDir": "./dist",
        "rootDir": "./src",
        "resolveJsonModule": true,
        "skipLibCheck": true
    },
    "include": ["src/**/*.ts"],
    "exclude": ["node_modules"]
}
