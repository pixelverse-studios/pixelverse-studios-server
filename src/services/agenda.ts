import { db, Tables } from '../lib/db'

// Types for agenda items
type AgendaStatus = 'pending' | 'in_progress' | 'completed'

interface AgendaItem {
    id: string
    name: string
    description: string | null
    status: AgendaStatus
    priority: number
    category: string | null
    due_date: string | null
    created_at: string
    updated_at: string
    completed_at: string | null
}

interface GetAllOptions {
    status?: string
    category?: string
    includeCompleted?: boolean
    limit?: number
    offset?: number
}

interface GetAllResult {
    items: AgendaItem[]
    total: number
}

/**
 * Get all agenda items with filtering and pagination
 * - status: 'pending', 'in_progress', 'completed', or 'active' (pending + in_progress)
 * - category: filter by exact category match
 * - includeCompleted: if true, include completed items (overridden by status filter)
 * - limit: max items to return (default 50)
 * - offset: pagination offset (default 0)
 */
const getAll = async (options: GetAllOptions = {}): Promise<GetAllResult> => {
    const {
        status,
        category,
        includeCompleted = false,
        limit = 50,
        offset = 0
    } = options

    let query = db.from(Tables.AGENDA_ITEMS).select('*', { count: 'exact' })

    // Apply status filter
    if (status === 'active') {
        // 'active' means pending + in_progress (excludes completed)
        query = query.in('status', ['pending', 'in_progress'])
    } else if (status === 'pending' || status === 'in_progress' || status === 'completed') {
        query = query.eq('status', status)
    } else if (!includeCompleted) {
        // Default: exclude completed unless explicitly requested
        query = query.neq('status', 'completed')
    }

    // Apply category filter
    if (category) {
        query = query.eq('category', category)
    }

    // Order by priority (0 = highest priority)
    query = query.order('priority', { ascending: true })

    // Apply pagination
    query = query.range(offset, offset + limit - 1)

    const { data, error, count } = await query

    if (error) throw error

    return {
        items: (data || []) as AgendaItem[],
        total: count || 0
    }
}

/**
 * Get a single agenda item by ID
 * @param id UUID of the agenda item
 * @returns AgendaItem or null if not found
 */
const getById = async (id: string): Promise<AgendaItem | null> => {
    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .select('*')
        .eq('id', id)
        .single()

    // Handle "no rows returned" as null, not an error
    if (error) {
        if (error.code === 'PGRST116') {
            return null
        }
        throw error
    }

    return data as AgendaItem
}

interface CreatePayload {
    name: string
    description?: string | null
    category?: string | null
    due_date?: string | null
}

/**
 * Create a new agenda item
 * - Sets status to 'pending'
 * - Sets priority to 0
 * - Timestamps are auto-generated by database
 */
const create = async (payload: CreatePayload): Promise<AgendaItem> => {
    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .insert([
            {
                name: payload.name,
                description: payload.description || null,
                category: payload.category || null,
                due_date: payload.due_date || null,
                status: 'pending',
                priority: 0,
                completed_at: null
            }
        ])
        .select()
        .single()

    if (error) throw error

    return data as AgendaItem
}

interface UpdatePayload {
    name?: string
    description?: string | null
    category?: string | null
    due_date?: string | null
}

/**
 * Update an agenda item's details
 * - Does NOT update status or priority (use separate endpoints)
 * - Send null to clear nullable fields
 * - Updates updated_at timestamp
 */
const update = async (
    id: string,
    payload: UpdatePayload
): Promise<AgendaItem | null> => {
    // Build update object with only provided fields
    const updateData: Record<string, unknown> = {
        updated_at: new Date().toISOString()
    }

    if (payload.name !== undefined) {
        updateData.name = payload.name
    }
    if (payload.description !== undefined) {
        updateData.description = payload.description
    }
    if (payload.category !== undefined) {
        updateData.category = payload.category
    }
    if (payload.due_date !== undefined) {
        updateData.due_date = payload.due_date
    }

    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .update(updateData)
        .eq('id', id)
        .select()
        .single()

    if (error) {
        if (error.code === 'PGRST116') {
            return null
        }
        throw error
    }

    return data as AgendaItem
}

export default {
    getAll,
    getById,
    create,
    update
}

// Export types for use in controller
export type { AgendaStatus, AgendaItem, GetAllOptions, GetAllResult }
