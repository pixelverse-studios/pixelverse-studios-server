import { db, Tables } from '../lib/db'

// Types for agenda items
type AgendaStatus = 'pending' | 'in_progress' | 'completed'

interface AgendaItem {
    id: string
    name: string
    description: string | null
    status: AgendaStatus
    priority: number
    category: string | null
    due_date: string | null
    created_at: string
    updated_at: string
    completed_at: string | null
}

interface GetAllOptions {
    status?: string
    category?: string
    includeCompleted?: boolean
    limit?: number
    offset?: number
}

interface GetAllResult {
    items: AgendaItem[]
    total: number
}

/**
 * Get all agenda items with filtering and pagination
 * - status: 'pending', 'in_progress', 'completed', or 'active' (pending + in_progress)
 * - category: filter by exact category match
 * - includeCompleted: if true, include completed items (overridden by status filter)
 * - limit: max items to return (default 50)
 * - offset: pagination offset (default 0)
 */
const getAll = async (options: GetAllOptions = {}): Promise<GetAllResult> => {
    const {
        status,
        category,
        includeCompleted = false,
        limit = 50,
        offset = 0
    } = options

    let query = db.from(Tables.AGENDA_ITEMS).select('*', { count: 'exact' })

    // Apply status filter
    if (status === 'active') {
        // 'active' means pending + in_progress (excludes completed)
        query = query.in('status', ['pending', 'in_progress'])
    } else if (status === 'pending' || status === 'in_progress' || status === 'completed') {
        query = query.eq('status', status)
    } else if (!includeCompleted) {
        // Default: exclude completed unless explicitly requested
        query = query.neq('status', 'completed')
    }

    // Apply category filter
    if (category) {
        query = query.eq('category', category)
    }

    // Order by priority (0 = highest priority)
    query = query.order('priority', { ascending: true })

    // Apply pagination
    query = query.range(offset, offset + limit - 1)

    const { data, error, count } = await query

    if (error) throw error

    return {
        items: (data || []) as AgendaItem[],
        total: count || 0
    }
}

/**
 * Get a single agenda item by ID
 * @param id UUID of the agenda item
 * @returns AgendaItem or null if not found
 */
const getById = async (id: string): Promise<AgendaItem | null> => {
    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .select('*')
        .eq('id', id)
        .single()

    // Handle "no rows returned" as null, not an error
    if (error) {
        if (error.code === 'PGRST116') {
            return null
        }
        throw error
    }

    return data as AgendaItem
}

interface CreatePayload {
    name: string
    description?: string | null
    category?: string | null
    due_date?: string | null
}

/**
 * Create a new agenda item
 * - Sets status to 'pending'
 * - Sets priority to 0
 * - Timestamps are auto-generated by database
 */
const create = async (payload: CreatePayload): Promise<AgendaItem> => {
    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .insert([
            {
                name: payload.name,
                description: payload.description || null,
                category: payload.category || null,
                due_date: payload.due_date || null,
                status: 'pending',
                priority: 0,
                completed_at: null
            }
        ])
        .select()
        .single()

    if (error) throw error

    return data as AgendaItem
}

interface UpdatePayload {
    name?: string
    description?: string | null
    category?: string | null
    due_date?: string | null
}

/**
 * Update an agenda item's details
 * - Does NOT update status or priority (use separate endpoints)
 * - Send null to clear nullable fields
 * - Updates updated_at timestamp
 */
const update = async (
    id: string,
    payload: UpdatePayload
): Promise<AgendaItem | null> => {
    // Build update object with only provided fields
    const updateData: Record<string, unknown> = {
        updated_at: new Date().toISOString()
    }

    if (payload.name !== undefined) {
        updateData.name = payload.name
    }
    if (payload.description !== undefined) {
        updateData.description = payload.description
    }
    if (payload.category !== undefined) {
        updateData.category = payload.category
    }
    if (payload.due_date !== undefined) {
        updateData.due_date = payload.due_date
    }

    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .update(updateData)
        .eq('id', id)
        .select()
        .single()

    if (error) {
        if (error.code === 'PGRST116') {
            return null
        }
        throw error
    }

    return data as AgendaItem
}

/**
 * Update an agenda item's status
 * - If status = 'completed': sets completed_at to now
 * - If status â‰  'completed': clears completed_at
 * - Always updates updated_at timestamp
 */
const updateStatus = async (
    id: string,
    status: AgendaStatus
): Promise<AgendaItem | null> => {
    const now = new Date().toISOString()

    const updateData: Record<string, unknown> = {
        status,
        updated_at: now,
        completed_at: status === 'completed' ? now : null
    }

    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .update(updateData)
        .eq('id', id)
        .select()
        .single()

    if (error) {
        if (error.code === 'PGRST116') {
            return null
        }
        throw error
    }

    return data as AgendaItem
}

/**
 * Update an agenda item's priority
 * - priority must be >= 0 (0 = highest priority)
 * - Updates updated_at timestamp
 */
const updatePriority = async (
    id: string,
    priority: number
): Promise<AgendaItem | null> => {
    const { data, error } = await db
        .from(Tables.AGENDA_ITEMS)
        .update({
            priority,
            updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select()
        .single()

    if (error) {
        if (error.code === 'PGRST116') {
            return null
        }
        throw error
    }

    return data as AgendaItem
}

interface ReorderResult {
    updated: number
    items: AgendaItem[]
}

/**
 * Bulk reorder agenda items by assigning priorities based on array index
 * - Index 0 = priority 0 (highest), index 1 = priority 1, etc.
 * - Updates updated_at for all affected items
 * - Handles partial updates gracefully (skips non-existent IDs)
 */
const reorder = async (itemIds: string[]): Promise<ReorderResult> => {
    const now = new Date().toISOString()
    const updatedItems: AgendaItem[] = []

    // Update each item's priority based on its index in the array
    for (let i = 0; i < itemIds.length; i++) {
        const { data, error } = await db
            .from(Tables.AGENDA_ITEMS)
            .update({
                priority: i,
                updated_at: now
            })
            .eq('id', itemIds[i])
            .select()
            .single()

        // Skip items that don't exist (graceful partial update)
        if (error) {
            if (error.code === 'PGRST116') {
                continue
            }
            throw error
        }

        updatedItems.push(data as AgendaItem)
    }

    return {
        updated: updatedItems.length,
        items: updatedItems
    }
}

/**
 * Delete an agenda item (hard delete)
 * @param id UUID of the agenda item
 * @returns true if deleted, false if not found
 */
const deleteItem = async (id: string): Promise<boolean> => {
    const { error, count } = await db
        .from(Tables.AGENDA_ITEMS)
        .delete({ count: 'exact' })
        .eq('id', id)

    if (error) throw error

    return (count ?? 0) > 0
}

export default {
    getAll,
    getById,
    create,
    update,
    updateStatus,
    updatePriority,
    reorder,
    delete: deleteItem
}

// Export types for use in controller
export type { AgendaStatus, AgendaItem, GetAllOptions, GetAllResult }
